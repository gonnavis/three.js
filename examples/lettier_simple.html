<!DOCTYPE html>
<html lang="en">

<head>
	<title>Panda3D</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="main.css">
</head>

<body>

	<script>window.THREE=true</script>
	<script src='/lib/vs_util/vs_util.js'></script>
	<script type="module">

		import * as THREE from '../build/three.module.js';
		window.THREE=THREE

		import { OrbitControls } from './jsm/controls/OrbitControls.js';

		var container, controls;
		var camera, scene, renderer;
		const frustumSize = 2

		;(async () => {
			await init();
			render();
		})()

		async function init() {

			container = document.createElement('div');
			document.body.appendChild(container);

			// camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.25, 200);
			// camera.position.set(0, 1, 3);

			const aspect = window.innerWidth / window.innerHeight;
			camera = new THREE.OrthographicCamera( frustumSize * aspect / - 2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / - 2, .001, 100 );
			camera.position.set(0, 0, 1);
			// camera.position.set(-5, 0, 0);

			window.camera = camera

			scene = new THREE.Scene();

			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			container.appendChild(renderer.domElement);

			controls = new OrbitControls(camera, renderer.domElement);
			controls.addEventListener('change', render); // use if there is no animation loop
			controls.update();

			window.addEventListener('resize', onWindowResize, false);

			{
				let itemSize

				let geo = new THREE.BoxBufferGeometry(1, 1, 1)
				// let geo = new THREE.PlaneBufferGeometry(1, 1)
				window.geo = geo

				itemSize = 4
				let p3d_Vertexs = []
				geo.attributes.position.array.forEach((n, i) => {
					p3d_Vertexs.push(n)
					if (i % 3 === 2) {
						p3d_Vertexs.push(1)
					}
				})
				geo.setAttribute('p3d_Vertex', new THREE.BufferAttribute(new Float32Array(p3d_Vertexs), itemSize));

				itemSize = 3
				let p3d_Normals = []
				geo.attributes.normal.array.forEach((n, i) => {
					p3d_Normals.push(n)
				})
				geo.setAttribute('p3d_Normal', new THREE.BufferAttribute(new Float32Array(p3d_Normals), itemSize));

				itemSize = 2
				let p3d_MultiTexCoord1s = []
				geo.attributes.uv.array.forEach((n, i) => {
					p3d_MultiTexCoord1s.push(n)
				})
				geo.setAttribute('p3d_MultiTexCoord1', new THREE.BufferAttribute(new Float32Array(p3d_MultiTexCoord1s), itemSize));

				itemSize = 4
				let p3d_Colors = []
				for (let i = 0, ii = 0; i < geo.attributes.position.count; i++, ii += itemSize) {
					p3d_Colors.push(1, 1, 1, 1)
				}
				geo.setAttribute('p3d_Color', new THREE.BufferAttribute(new Float32Array(p3d_Colors), itemSize));

				// let mtl = new THREE.MeshStandardMaterial({
				// 	color: 'red',
				// })
				let vertexShader = await (await fetch('./base.vert')).text()
				let fragmentShader = await (await fetch('./base.frag')).text()

				window.p3d_Texture0 = new THREE.TextureLoader().load("/lib/three.js_github_gonnavis/examples/models/lwo/Images/material-Phong-metal/167_COLOR.JPG", render);
				window.p3d_Texture1 = new THREE.TextureLoader().load("/lib/3d-game-shaders-for-beginners_github/demonstration/eggs/mill-scene/tex/normal.png", render);
				window.p3d_Texture2 = new THREE.TextureLoader().load("/lib/3d-game-shaders-for-beginners_github/demonstration/eggs/mill-scene/tex/no-specular.png", render);

				window.o_p3d_LightSource = {
					color: new THREE.Vector4(1,1,1,1),
					ambient: new THREE.Vector4(1,1,1,1),
					diffuse: new THREE.Vector4(1,1,1,1),
					specular: new THREE.Vector4(1,1,1,1),
					position: new THREE.Vector4(),//Panda3D sets p3d_LightSource[i].position.w to zero if this is a directional light.
					spotDirection: new THREE.Vector3(-1,-1,-1),
					spotExponent: 0,
					spotCutoff: 10,
					spotCosCutoff: -1,
					constantAttenuation: 1,
					linearAttenuation: 0,
					quadraticAttenuation: 1,
					attenuation: new THREE.Vector3(1,1,1,1),///todo not need
					shadowMap: p3d_Texture0,
					shadowViewMatrix: new THREE.Matrix4(),
				}

				window.uniforms = {
					trans_world_to_view:{value:null},
					trans_view_to_world:{value:null},
					p3d_NormalMatrix:{value:new THREE.Matrix3()},
					p3d_Texture0: { value: p3d_Texture0 },
					p3d_Texture1: { value: p3d_Texture1 },
					p3d_Texture2: { value: p3d_Texture2 },
					pi: { value: new THREE.Vector2(0, Math.PI) },
					gamma: { value: new THREE.Vector2(1, 0) },
					p3d_Material: {
						value: {
							ambient: new THREE.Vector4(1,1,1,1),
							diffuse: new THREE.Vector4(1,1,1,1),
							emission: new THREE.Vector4(1,1,1,1),
							specular: new THREE.Vector3(1,1,1),
							shininess: 1,
						}
					},
					p3d_ProjectionMatrix: { value: new THREE.Matrix4() },
					p3d_ModelViewMatrix: { value: new THREE.Matrix4() },
					isParticle: { value: new THREE.Vector2() },
					p3d_LightSource: {
						value: [o_p3d_LightSource],
						// value: [o_p3d_LightSource, o_p3d_LightSource, o_p3d_LightSource, o_p3d_LightSource],
					},
				}
				let mtl = new THREE.RawShaderMaterial({
					uniforms,
					vertexShader,
					fragmentShader,
				})
				let mesh = new THREE.Mesh(geo, mtl)
				window.mesh = mesh
				scene.add(mesh)
			}
			{
				const light = new THREE.HemisphereLight(0xffffbb, 0x080820, 1);
				scene.add(light);
			}
			{
				const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
				scene.add(directionalLight);
				scene.add(directionalLight.target);
				directionalLight.target.position.set(-.5, 0, -1)
			}

		}

		function onWindowResize() {

			// camera.aspect = window.innerWidth / window.innerHeight;
			// camera.updateProjectionMatrix();
			// renderer.setSize(window.innerWidth, window.innerHeight);
			// render();

			const aspect = window.innerWidth / window.innerHeight;
			camera.left = - frustumSize * aspect / 2;
			camera.right = frustumSize * aspect / 2;
			camera.top = frustumSize / 2;
			camera.bottom = - frustumSize / 2;
			camera.updateProjectionMatrix();
			renderer.setSize( window.innerWidth, window.innerHeight );
			render();

		}

		//

		function render() {
			console.log('render')
			camera.updateMatrixWorld()
			camera.updateProjectionMatrix()
			uniforms.p3d_ProjectionMatrix.value = camera.projectionMatrix
			uniforms.p3d_ModelViewMatrix.value = mesh.modelViewMatrix
			// uniforms.p3d_ModelViewMatrix.value.getInverse(camera.modelViewMatrix)

			uniforms.trans_world_to_view.value = camera.matrixWorldInverse
			uniforms.trans_view_to_world.value = camera.matrixWorld
			uniforms.p3d_NormalMatrix.value = new THREE.Matrix3().setFromMatrix4(new THREE.Matrix4().extractRotation(camera.matrixWorldInverse)) 

			o_p3d_LightSource.position.copy(new THREE.Vector4(.2,.4,.6,0).applyMatrix4(mesh.modelViewMatrix))
			// o_p3d_LightSource.position.copy(new THREE.Vector4(0,0,1,0).applyMatrix4(mesh.modelViewMatrix))

			// uniforms.p3d_Material.value.ambient = new THREE.Vector4(0, 0, .5, 1)
			// uniforms.p3d_Material.value.diffuse = new THREE.Vector4(1, 0, 0, 1)
			// uniforms.p3d_Material.value.emission = new THREE.Vector4(.5, .5, .5, 1)
			// uniforms.p3d_Material.value.specular = new THREE.Vector3(0, 0, 0)
			// uniforms.p3d_Material.value.shininess = 1

			renderer.render(scene, camera);

		}

	</script>

</body>

</html>
