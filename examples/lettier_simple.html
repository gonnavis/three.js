<!DOCTYPE html>
<html lang="en">

<head>
	<title>Panda3D</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="main.css">
</head>

<body>

	<script type="module">

		import * as THREE from '../build/three.module.js';

		import { OrbitControls } from './jsm/controls/OrbitControls.js';

		var container, controls;
		var camera, scene, renderer;

		(async () => {
			await init();
			render();
		})()

		async function init() {

			container = document.createElement('div');
			document.body.appendChild(container);

			camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.25, 200);
			camera.position.set(0, 1, 3);
			window.camera = camera

			scene = new THREE.Scene();

			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			container.appendChild(renderer.domElement);

			controls = new OrbitControls(camera, renderer.domElement);
			controls.addEventListener('change', render); // use if there is no animation loop
			controls.update();

			window.addEventListener('resize', onWindowResize, false);

			{
				// let geo = new THREE.BoxBufferGeometry(1, 1, 1)
				let geo = new THREE.PlaneBufferGeometry(1, 1)
				window.geo=geo
				// let mtl = new THREE.MeshStandardMaterial({
				// 	color: 'red',
				// })
				let vertexShader = await (await fetch('./base.vert')).text()
				let fragmentShader = await (await fetch('./base.frag')).text()
				const textureABC = new THREE.TextureLoader().load("/lib/three.js_github_gonnavis/examples/models/lwo/Images/material-Phong-metal/167_COLOR.JPG");
				textureABC.wrapS = THREE.RepeatWrapping;
				textureABC.wrapT = THREE.RepeatWrapping;
				textureABC.repeat.set(4, 4);
				let uniforms = {
					isParticle: { value: new THREE.Vector2() },
					p3d_LightSource: {
						value: [
							{
								color: new THREE.Vector4(),
								ambient: new THREE.Vector4(),
								diffuse: new THREE.Vector4(),
								specular: new THREE.Vector4(),
								position: new THREE.Vector4(),
								spotDirection: new THREE.Vector3(),
								spotExponent: 0,
								spotCutoff: 0,
								spotCosCutoff: 0,
								constantAttenuation: 0,
								linearAttenuation: 0,
								quadraticAttenuation: 0,
								attenuation: new THREE.Vector3(),
								sampler2DShadow: textureABC,
								shadowViewMatrix: new THREE.Matrix4(),
							}, {
								color: new THREE.Vector4(),
								ambient: new THREE.Vector4(),
								diffuse: new THREE.Vector4(),
								specular: new THREE.Vector4(),
								position: new THREE.Vector4(),
								spotDirection: new THREE.Vector3(),
								spotExponent: 0,
								spotCutoff: 0,
								spotCosCutoff: 0,
								constantAttenuation: 0,
								linearAttenuation: 0,
								quadraticAttenuation: 0,
								attenuation: new THREE.Vector3(),
								sampler2DShadow: textureABC,
								shadowViewMatrix: new THREE.Matrix4(),
							}, {
								color: new THREE.Vector4(),
								ambient: new THREE.Vector4(),
								diffuse: new THREE.Vector4(),
								specular: new THREE.Vector4(),
								position: new THREE.Vector4(),
								spotDirection: new THREE.Vector3(),
								spotExponent: 0,
								spotCutoff: 0,
								spotCosCutoff: 0,
								constantAttenuation: 0,
								linearAttenuation: 0,
								quadraticAttenuation: 0,
								attenuation: new THREE.Vector3(),
								sampler2DShadow: textureABC,
								shadowViewMatrix: new THREE.Matrix4(),
							}, {
								color: new THREE.Vector4(),
								ambient: new THREE.Vector4(),
								diffuse: new THREE.Vector4(),
								specular: new THREE.Vector4(),
								position: new THREE.Vector4(),
								spotDirection: new THREE.Vector3(),
								spotExponent: 0,
								spotCutoff: 0,
								spotCosCutoff: 0,
								constantAttenuation: 0,
								linearAttenuation: 0,
								quadraticAttenuation: 0,
								attenuation: new THREE.Vector3(),
								sampler2DShadow: textureABC,
								shadowViewMatrix: new THREE.Matrix4(),
							},
						]
					},
				}
				let mtl = new THREE.RawShaderMaterial({
					uniforms,
					vertexShader,
					fragmentShader,
				})
				let mt
				let mesh = new THREE.Mesh(geo, mtl)
				scene.add(mesh)
			}
			{
				const light = new THREE.HemisphereLight(0xffffbb, 0x080820, 1);
				scene.add(light);
			}
			{
				const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
				scene.add(directionalLight);
				scene.add(directionalLight.target);
				directionalLight.target.position.set(-.5, 0, -1)
			}

		}

		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);

			render();

		}

		//

		function render() {

			renderer.render(scene, camera);

		}

	</script>

</body>

</html>
