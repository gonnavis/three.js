<html>
	<head>
		<title>three.js pbr learnopengl.com</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="../build/three.min.js"></script>
		<script src="../examples/js/controls/OrbitControls.js"></script>
		<script src="../examples/js/libs/dat.gui.min.js"></script>

		<script>
			let scene = new THREE.Scene();
			let camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 10 );
			// camera.position.set(1.1151789450070635,  0.5730500771892872,  1.6637508159544183)
			camera.position.set(0,0,3)
			camera.lookAt(0,0,0)

			let renderer = new THREE.WebGLRenderer({antialias:true});
			renderer.setSize( window.innerWidth, window.innerHeight );
      renderer.setClearColor('blue')
			document.body.appendChild( renderer.domElement );

			let controls = new THREE.OrbitControls(camera , renderer.domElement);


			let geometry=new THREE.IcosahedronGeometry(1,4);
			window.geometry=geometry


			// material
				window.uniforms = {
					// "colorTexture": { value: new THREE.TextureLoader().load( 'a.png' ) }
					albedo:{value:new THREE.Color('red')},
					metallic:{value:.2},
					roughness:{value:.2},
					ao:{value:0},
					reflectivity:{value:.04},
					lightPositions:{value:[
						camera.position.clone().add(new THREE.Vector3(.9,.9,0)),
						camera.position.clone().add(new THREE.Vector3(.9,-.9,0)),
						camera.position.clone().add(new THREE.Vector3(-.9,.9,0)),
						camera.position.clone().add(new THREE.Vector3(-.9,-.9,0)),
					]},
					lightColors:{value:[
						new THREE.Color('white'),
						new THREE.Color('white'),
						new THREE.Color('white'),
						new THREE.Color('white'),
					]},
					camPos:{value:camera.position},
				};
				let material = new THREE.ShaderMaterial( {

					uniforms: uniforms,
					vertexShader: /* glsl */`
						out vec2 TexCoords;
						out vec3 WorldPos;
						out vec3 Normal;

						void main()
						{
								TexCoords = uv;
								WorldPos = vec3(modelMatrix * vec4(position, 1.0));
								Normal = mat3(modelMatrix) * normal;   

								gl_Position =  projectionMatrix * viewMatrix * vec4(WorldPos, 1.0);
						}
          `,
					fragmentShader: /* glsl */`
						in vec2 TexCoords;
						in vec3 WorldPos;
						in vec3 Normal;

						// material parameters
						uniform vec3 albedo;
						uniform float metallic;
						uniform float roughness;
						uniform float ao;
						uniform float reflectivity;

						// lights
						uniform vec3 lightPositions[4];
						uniform vec3 lightColors[4];

						uniform vec3 camPos;

						const float PI = 3.14159265359;
						// ----------------------------------------------------------------------------
						float DistributionGGX(vec3 N, vec3 H, float roughness)
						{
								float a = roughness*roughness;
								float a2 = a*a;
								float NdotH = max(dot(N, H), 0.0);
								float NdotH2 = NdotH*NdotH;

								float nom   = a2;
								float denom = (NdotH2 * (a2 - 1.0) + 1.0);
								denom = PI * denom * denom;

								return nom / max(denom, 0.0000001); // prevent divide by zero for roughness=0.0 and NdotH=1.0
						}
						// ----------------------------------------------------------------------------
						float GeometrySchlickGGX(float NdotV, float roughness)
						{
								float r = (roughness + 1.0);
								float k = (r*r) / 8.0;

								float nom   = NdotV;
								float denom = NdotV * (1.0 - k) + k;

								return nom / denom;
						}
						// ----------------------------------------------------------------------------
						float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)
						{
								float NdotV = max(dot(N, V), 0.0);
								float NdotL = max(dot(N, L), 0.0);
								float ggx2 = GeometrySchlickGGX(NdotV, roughness);
								float ggx1 = GeometrySchlickGGX(NdotL, roughness);

								return ggx1 * ggx2;
						}
						// ----------------------------------------------------------------------------
						vec3 fresnelSchlick(float cosTheta, vec3 F0)
						{
								return F0 + (1.0 - F0) * pow(max(1.0 - cosTheta, 0.0), 5.0);
						}
						// ----------------------------------------------------------------------------
						void main()
						{		
								vec3 N = normalize(Normal);
								vec3 V = normalize(camPos - WorldPos);

								// calculate reflectance at normal incidence; if dia-electric (like plastic) use F0 
								// of 0.04 and if it's a metal, use the albedo color as F0 (metallic workflow)    
								// vec3 F0 = vec3(0.04); 
								vec3 F0 = vec3( 0.16 * ( reflectivity * reflectivity ) ); 
								F0 = mix(F0, albedo, metallic);

								// reflectance equation
								vec3 Lo = vec3(0.0);
								for(int i = 0; i < 4; ++i) 
								{
										// calculate per-light radiance
										vec3 L = normalize(lightPositions[i] - WorldPos);
										vec3 H = normalize(V + L);
										float distance = length(lightPositions[i] - WorldPos);
										float attenuation = 1.0 / (distance * distance);
										vec3 radiance = lightColors[i] * attenuation;

										// Cook-Torrance BRDF
										float NDF = DistributionGGX(N, H, roughness);   
										float G   = GeometrySmith(N, V, L, roughness);      
										vec3 F    = fresnelSchlick(clamp(dot(H, V), 0.0, 1.0), F0);
											
										vec3 nominator    = NDF * G * F; 
										float denominator = 4. * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);
										vec3 specular = nominator / max(denominator, 0.001); // prevent divide by zero for NdotV=0.0 or NdotL=0.0
										
										// kS is equal to Fresnel
										vec3 kS = F;
										// for energy conservation, the diffuse and specular light can't
										// be above 1.0 (unless the surface emits light); to preserve this
										// relationship the diffuse component (kD) should equal 1.0 - kS.
										vec3 kD = vec3(1.0) - kS;
										// multiply kD by the inverse metalness such that only non-metals 
										// have diffuse lighting, or a linear blend if partly metal (pure metals
										// have no diffuse light).
										kD *= 1.0 - metallic;	  

										// scale light by NdotL
										float NdotL = max(dot(N, L), 0.0);        

										// add to outgoing radiance Lo
										Lo += (kD * albedo / PI + specular) * radiance * NdotL;  // note that we already multiplied the BRDF by the Fresnel (kS) so we won't multiply by kS again
								}   
								
								// ambient lighting (note that the next IBL tutorial will replace 
								// this ambient lighting with environment lighting).
								vec3 ambient = vec3(0.03) * albedo * ao;

								vec3 color = ambient + Lo;

								// HDR tonemapping
								color = color / (color + vec3(1.0));
								// gamma correct
								color = pow(color, vec3(1.0/2.2)); 

								gl_FragColor = vec4(color, 1.0);
						}

          `

				} );


			let mesh = new THREE.Mesh( geometry, material );

			scene.add(mesh);

			gui=new dat.GUI()
			gui.add(uniforms.metallic,'value').name('metallic').min(0).max(1)
			gui.add(uniforms.roughness,'value').name('roughness').min(0).max(1)
			gui.add(uniforms.ao,'value').name('ao').min(0).max(1)
			gui.add(uniforms.reflectivity,'value').name('reflectivity').min(0).max(1)

			let animate = function () {
				requestAnimationFrame( animate );

				renderer.render(scene, camera);
			};

			animate();
		</script>
	</body>
</html>