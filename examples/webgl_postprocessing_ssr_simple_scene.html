<!DOCTYPE html>
<html lang="en">

<head>
	<title>three.js webgl - postprocessing - Screen Space Ambient Occlusion</title>
	<meta charset="utf-8">
	<meta name="viewport"
				content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css"
				rel="stylesheet"
				href="main.css">
	<style>
	</style>
</head>

<body>
	<div id="info">
		<a href="https://threejs.org"
			 target="_blank"
			 rel="noopener">three.js</a> - screen space ambient occlusion<br />
	</div>

	<script type="module">

		import * as THREE from '../build/three.module.js';
		window.THREE = THREE

		import Stats from './jsm/libs/stats.module.js';
		import { GUI } from './jsm/libs/dat.gui.module.js';

		import { EffectComposer } from './jsm/postprocessing/EffectComposer.js';
		import { OrbitControls } from './jsm/controls/OrbitControls.js'
		
		import { SSRPass } from './jsm/postprocessing/SSRPass.js';
		
		var container, stats;
		var camera, scene, renderer;
		var composer;
		var group;
		var s = {}
		var gui
		var params = {
			enableSSR: true,
		}

		init();
		animate();

		function init() {

			container = document.createElement('div');
			document.body.appendChild(container);

			renderer = new THREE.WebGLRenderer();
			s.renderer = renderer
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);


			{
				camera = new THREE.PerspectiveCamera( 65, window.innerWidth / window.innerHeight, 100, 700 );
				s.camera=camera
				window.camera=camera
				camera.position.z=200
				// camera.position.set(134.05726029286836,  210.1879758063986,  166.88219134820477)

				scene = new THREE.Scene();

				s.scene = scene
				// scene.background = new THREE.Color(0xaaaaaa);
				{//mesh
					let geo = new THREE.BoxBufferGeometry(100, 100, 100)
					// let geo = new THREE.PlaneBufferGeometry(2, 2)
					// let geo = new THREE.IcosahedronBufferGeometry(.5, 3)
					let mtl = new THREE.MeshBasicMaterial({
						color: 'red',
						side: THREE.DoubleSide,
					})
					let mesh = new THREE.Mesh(geo, mtl)
					s.mesh = mesh
					s.scene.add(mesh)
					window.mesh = mesh
					// mesh.position.x=2
					// mesh.position.y=1
				}
				// {//mesh 2
				//   let geo = new THREE.BoxBufferGeometry(1, 1, 1)
				//   // let geo = new THREE.IcosahedronBufferGeometry(.5, 2)
				//   let mesh = new THREE.Mesh(geo, s.mtl_depth)
				//   s.mesh_2 = mesh
				//   // s.scene.add(mesh)
				//   window.mesh = mesh
				//   mesh.position.x = 2
				// }
				{//ground
					let geo = new THREE.PlaneBufferGeometry(500, 500)
					let mtl = new THREE.MeshBasicMaterial({
						color: 'blue',
						side: THREE.DoubleSide,
					})
					let mesh = new THREE.Mesh(geo, mtl)
					s.ground = mesh
					s.scene.add(mesh)
					// mesh.rotation.x = -Math.PI / 2
					// mesh.position.y = -.5
					geo.rotateX(-Math.PI / 2)
					geo.translate(0, -50, 0)
				}
			}

			new OrbitControls(s.camera, s.renderer.domElement)

			stats = new Stats();
			container.appendChild(stats.dom);

			var width = window.innerWidth;
			var height = window.innerHeight;

			composer = new EffectComposer(renderer);

			var ssrPass = new SSRPass(scene, camera, width, height);
			ssrPass.kernelRadius = 16;
			composer.addPass(ssrPass);

			// GUI

			gui = new GUI( { width: 400 } );
			ssrPass.surfDist=4.2
			ssrPass.output=1
			gui.add(ssrPass, 'output', {
				'Default': SSRPass.OUTPUT.Default,
				'DefaultBlur': SSRPass.OUTPUT.DefaultBlur,
				'SSR Only': SSRPass.OUTPUT.SSR,
				'SSR Only + Blur': SSRPass.OUTPUT.Blur,
				'Beauty': SSRPass.OUTPUT.Beauty,
				'Depth': SSRPass.OUTPUT.Depth,
				'Normal': SSRPass.OUTPUT.Normal
			}).onChange(function (value) {

				ssrPass.output = parseInt(value);

			});
			gui.add(params, 'enableSSR').name( 'Enable SSR' );
			gui.add(ssrPass, 'opacity').min(0).max(1);
			gui.add(ssrPass, 'maxDistance').min(0).max(3000);
			gui.add(ssrPass, 'surfDist').min(0).max(10).step(.1);


			window.addEventListener('resize', onWindowResize, false);

		}

		function onWindowResize() {

			var width = window.innerWidth;
			var height = window.innerHeight;

			camera.aspect = width / height;
			camera.updateProjectionMatrix();

			renderer.setSize(width, height);
			composer.setSize(width, height);

		}

		function animate() {

			requestAnimationFrame(animate);

			stats.begin();
			render();
			stats.end();

		}

		function render() {

			var timer = performance.now();
			if (0) {
				group.rotation.x = timer * 0.0002;
				group.rotation.y = timer * 0.0001;
			}

			composer.render();

		}

	</script>
</body>

</html>
