<!DOCTYPE html>
<html lang="en">

<head>
  <title>three.js webgl - postprocessing - Orthographic Screen Space Reflection</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <link type="text/css" rel="stylesheet" href="main.css">
</head>

<body>
<div id="info">
  <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> -
  OrthographicSSRPass demo 2 by <a href="https://github.com/gonnavis" target="_blank">Vis</a>.<br />
  based on <a href="https://threejs.org/examples/?q=stl#webgl_loader_stl" target="_blank">this scene</a>
</div>

<script type="module">

  import * as THREE from '../build/three.module.js';

		import Stats from './jsm/libs/stats.module.js';
		import { GUI } from './jsm/libs/dat.gui.module.js';

		import { STLLoader } from './jsm/loaders/STLLoader.js';

		import { EffectComposer } from './jsm/postprocessing/EffectComposer.js';
		import { OrthographicSSRPass } from './jsm/postprocessing/OrthographicSSRPass.js';
		import { OrbitControls } from './jsm/controls/OrbitControls.js'

		var initialFrustumSize = 1200;
		var params = {
			enableSSR: true,
		}
		var composer
		var orthographicSSRPass

		var container, stats;

		var camera, cameraTarget, scene, renderer;
		
		init();
		animate();
		
		function init() {
			
			container = document.createElement('div');
			document.body.appendChild(container);
			
			var cameraNear = 1
			var cameraFar = 1800
			var aspect = window.innerWidth / window.innerHeight;
			camera = new THREE.OrthographicCamera(initialFrustumSize * aspect / - 2, initialFrustumSize * aspect / 2, initialFrustumSize / 2, initialFrustumSize / - 2, cameraNear, cameraFar);
			camera.position.set(-3.841971267097966, 1.628450668378282, 2.7545244967964964)
			camera.position.multiplyScalar(200)

			scene = new THREE.Scene();
			scene.fog = new THREE.Fog(0x72645b, 2*400, 15*400);


			// Ground

			var plane = new THREE.Mesh(
				new THREE.PlaneBufferGeometry(40*400, 40*400),
				new THREE.MeshPhongMaterial({ color: 0x999999, specular: 0x101010 })
			);
			plane.rotation.x = - Math.PI / 2;
			plane.position.y = - 0.5*400;
			scene.add(plane);

			plane.receiveShadow = true;


			// ASCII file

			var loader = new STLLoader();
			loader.load('./models/stl/ascii/slotted_disk.stl', function (geometry) {

				var material = new THREE.MeshPhongMaterial({ color: 0xff5533, specular: 0x111111, shininess: 200 });
				var mesh = new THREE.Mesh(geometry, material);

				mesh.position.set(0, - 0.25*400, 0.6*400);
				mesh.rotation.set(0, - Math.PI / 2, 0);
				mesh.scale.set(0.5*400, 0.5*400, 0.5*400);

				mesh.castShadow = true;
				mesh.receiveShadow = true;

				scene.add(mesh);

			});


			// Binary files

			var material = new THREE.MeshPhongMaterial({ color: 0xAAAAAA, specular: 0x111111, shininess: 200 });

			loader.load('./models/stl/binary/pr2_head_pan.stl', function (geometry) {

				var mesh = new THREE.Mesh(geometry, material);

				mesh.position.set(0, - 0.37, - 0.6);
				mesh.position.multiplyScalar(400)
				mesh.rotation.set(- Math.PI / 2, 0, 0);
				mesh.scale.set(2, 2, 2);
				mesh.scale.multiplyScalar(400)

				mesh.castShadow = true;
				mesh.receiveShadow = true;

				scene.add(mesh);

			});

			loader.load('./models/stl/binary/pr2_head_tilt.stl', function (geometry) {

				var mesh = new THREE.Mesh(geometry, material);

				mesh.position.set(0.136, - 0.37, - 0.6);
				mesh.position.multiplyScalar(400)
				mesh.rotation.set(- Math.PI / 2, 0.3, 0);
				mesh.scale.set(2, 2, 2);
				mesh.scale.multiplyScalar(400)

				mesh.castShadow = true;
				mesh.receiveShadow = true;

				scene.add(mesh);

			});

			// Colored binary STL
			loader.load('./models/stl/binary/colored.stl', function (geometry) {

				var meshMaterial = material;
				if (geometry.hasColors) {

					meshMaterial = new THREE.MeshPhongMaterial({ opacity: geometry.alpha, vertexColors: true });

				}

				var mesh = new THREE.Mesh(geometry, meshMaterial);

				mesh.position.set(0.5, 0.2, 0);
				mesh.position.multiplyScalar(400)
				mesh.rotation.set(- Math.PI / 2, Math.PI / 2, 0);
				mesh.scale.set(0.3, 0.3, 0.3);
				mesh.scale.multiplyScalar(400)

				mesh.castShadow = true;
				mesh.receiveShadow = true;

				scene.add(mesh);

			});


			// Lights

			scene.add(new THREE.HemisphereLight(0x443333, 0x111122));

			addShadowedLight(1, 1, 1, 0xffffff, 1.35);
			addShadowedLight(0.5, 1, - 1, 0xffaa00, 1);
			// renderer

			renderer = new THREE.WebGLRenderer({ antialias: false });
			// renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			// renderer.outputEncoding = THREE.sRGBEncoding;

			renderer.shadowMap.enabled = true;

			container.appendChild(renderer.domElement);



			composer = new EffectComposer(renderer);
			orthographicSSRPass = new OrthographicSSRPass(scene, camera, innerWidth, innerHeight, initialFrustumSize);
			composer.addPass(orthographicSSRPass);

			// Init gui
			var gui = new GUI();
			orthographicSSRPass.surfDist = 7

			gui.add(orthographicSSRPass, 'output', {
				'Default': OrthographicSSRPass.OUTPUT.Default,
				'DefaultBlur': OrthographicSSRPass.OUTPUT.DefaultBlur,
				'OrthographicSSR Only': OrthographicSSRPass.OUTPUT.OrthographicSSR,
				'OrthographicSSR Only + Blur': OrthographicSSRPass.OUTPUT.Blur,
				'Beauty': OrthographicSSRPass.OUTPUT.Beauty,
				'Depth': OrthographicSSRPass.OUTPUT.Depth,
				'Normal': OrthographicSSRPass.OUTPUT.Normal
			}).onChange(function (value) {

				orthographicSSRPass.output = parseInt(value);

			});
			gui.add(params, 'enableSSR').name( 'Enable SSR' );
			gui.add(orthographicSSRPass, 'opacity').min(0).max(1);
			gui.add(orthographicSSRPass, 'maxDistance').min(0).max(2);
			// gui.add(orthographicSSRPass, 'stepStride').min(1).max(10).step(1);
			gui.add(orthographicSSRPass, 'surfDist').min(1).max(20).step(.1);
			gui.add(orthographicSSRPass, 'isFade');
			gui.add(orthographicSSRPass, 'fadeIntesity').min(0).max(10).step(.1);

			new OrbitControls(camera, renderer.domElement)

			// stats

			stats = new Stats();
			container.appendChild(stats.dom);

			//

			window.addEventListener('resize', onWindowResize, false);

		}

		function addShadowedLight(x, y, z, color, intensity) {

			var directionalLight = new THREE.DirectionalLight(color, intensity);
			directionalLight.position.set(x, y, z);
			directionalLight.position.multiplyScalar(400)
			scene.add(directionalLight);

			directionalLight.castShadow = true;

			var d = 1;
			directionalLight.shadow.camera.left = - d;
			directionalLight.shadow.camera.right = d;
			directionalLight.shadow.camera.top = d;
			directionalLight.shadow.camera.bottom = - d;

			directionalLight.shadow.camera.near = 1*400;
			directionalLight.shadow.camera.far = 4*400;

			directionalLight.shadow.bias = - 0.002;

		}

		function onWindowResize() {

			var aspect = window.innerWidth / window.innerHeight;

			camera.left = - initialFrustumSize * aspect / 2;
			camera.right = initialFrustumSize * aspect / 2;
			camera.top = initialFrustumSize / 2;
			camera.bottom = - initialFrustumSize / 2;

			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);
			composer.setSize(window.innerWidth, window.innerHeight);

		}

		function animate() {

			requestAnimationFrame(animate);

			render();
			stats.update();

		}

		function render() {

			if(params.enableSSR){
				orthographicSSRPass.setFrustumSize(initialFrustumSize/camera.zoom)
				composer.render();
			}else{
				renderer.render(scene,camera)
			}

		}

	</script>
</body>

</html>
